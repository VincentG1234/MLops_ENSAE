["Cloud Data Infrastructure project :\nDeliverable 1\nBLANC Florent\nGIMENES Vincent\nGONCHAROV Gleb\n1.1 Dataset Description :\nOur dataset comes from datahub.io ( https://datahub.io/core/atp-world-tour-tennis-data ).It\ncontains 5 connected tables that allow an analysis of tennis games and tournaments.", "dataset comes from datahub.io ( https://datahub.io/core/atp-world-tour-tennis-data ).It contains 5 connected tables that allow an analysis of tennis games and tournaments.The 5\ntables are the following :\n- tournaments table which has 28 columns and contains information about the name,\nlocation, conditions (surface and indoor or outdoor) and year of the tournament but also\nabout the winners of the tournament in singles and doubles\n- match scores table which has 24 columns and contains information on the tournament\nand round in which the match was played, who won, who lost but also the exact score of the\nmatch and how sets and tiebreaks each player won.", "who won, who lost but also the exact score of the match and how sets and tiebreaks each player won.- match stats table which contains different statistics for each game.We can find for\nexample match durations, match_id and the tournament in which the game was played but\nalso the number of aces, double faults or unforced errors and serving statistics as serve\nrating or average serve speed on 1st and 2nd serves.", "double faults or unforced errors and serving statistics as serve rating or average serve speed on 1st and 2nd serves.- rankings table which contains information on the weekly moves in the ATP rankings of\nthe players\n- player overview table contains information about the players as their birth date,\nresidence, the year they turned pro, their weight, height, strong hand and if their backhand\nis one-handed or two handed\n2.2 Use Cases :\n- End User View :", "Who won Wimbledon in 1997 in singles?\nIn the tournament table select the singles_winner_name value of the row\nwhere tourney_year is 1997 and tourney_name is Wimbledon", "Who has won the most tournaments on clay court in singles ?\nFilter the tournaments played on clay in the tournament table by selecting the\ntournaments for which tourney_surface= \u2018clay\u2019 and then count how many\ntimes each player appears in singles_winner_name. Group the results by the\nwinner\u2019s name and then order it in descending order and show only the first\none.", "When did Nadal win the first tournament?\nFilter the tournaments where Nadal was the winner with\nsingles_winner_name = \u2018Rafael Nadal\u2019 in the tournament table . Sort the\ntournaments by year and month in ascending order with \u2018tourney_year\u2019 and\n\u2018tourney_month\u2019 in the tournament table to list his earliest win first and show only\nthe first one.", "How many tournaments were held in Marseille?\nFilter the tournaments played in Marseille with \u2018tourney_location\u2019 =\n\u2018Marseille\u2019 in the tournament table and count them.\nThose four questions could be asked by any user who seeks to acquire more knowledge from\nthe application on tennis history without going into the details of the statistics.Data Analyst (DA):", "What was the difference between winner_serve_rating and loser_serve_rating\n(average over all matches) for each tournament?\n(DA-A) Join the match stats and match score table on the match_id column.\nRetrieve the tournament name from the match_scores table. Calculate the average\ndifference between the winner's and loser's serve ratings for all matches within each\ntournament with winner_serve_rating and loser_serve_rating in the match stats\ntable.", "winner's and loser's serve ratings for all matches within each tournament with winner_serve_rating and loser_serve_rating in the match stats table.What is Djokovic\u2019s winning percentage on each surface?(DA-B) Join the match scores table with the tournament table on the tourney_slug\ncolumn.For each surface (selected from the tournament_surface column) we have to\ncompute the number of matches played and the number of matches won by\nDjokovic.", "the tournament_surface column) we have to compute the number of matches played and the number of matches won by Djokovic.So first we select the surface and from the match scores table retrieve\nwinner_slug = 'Novak Djokovic' to count only matches where Djokovic is the winner.From the match scores table retrieve winner_slug = 'Novak Djokovic' and loser_slug =\n'Novak Djokovic' to count matches where Djokovic played.", "the match scores table retrieve winner_slug = 'Novak Djokovic' and loser_slug = 'Novak Djokovic' to count matches where Djokovic played.Then divide the count of\nwins by the count of games played and multiply by 100 to get the percentage of win\non each surface\nThose two questions could be asked by a data analyst trying to analyze tennis and predict\ntheir outcome by for the first one trying to appreciate the importance of serve and the\nsecond how the surface of a court impacts a certain player\u2019s winning rate.", "appreciate the importance of serve and the second how the surface of a court impacts a certain player\u2019s winning rate.Deliverable 2:\n2.1 First denormalization (Surcharge):\nLet us look at the query (DA-B).We need to join the tournament table just to retrieve the\nkind of surface.Yet, the kind of surface is one of the main distinctions that we can make to\ncompare tournaments, and that is often relevant when one wants to analyze matches.", "main distinctions that we can make to compare tournaments, and that is often relevant when one wants to analyze matches.Indeed, players have different play styles and formations which causes many of them to have\nvery different results depending on the surface.Therefore, to optimize the query (DA-B), and maybe plenty of other queries of the same\nkind, it could be interesting to perform a denormalization by \u201cSurcharge\u201d to add directly to\nthe match scores table the type of the surface.", "interesting to perform a denormalization by \u201cSurcharge\u201d to add directly to the match scores table the type of the surface.This enables a data analyst to avoid making a\njoin just to retrieve one column.Moreover, integrating the surface type directly into the match scores table is an effective\napproach due to the low cardinality of this attribute.Since there are only three possible\nvalues (clay, grass, hard), duplicating this information has a negligible impact on storage.", "this attribute.Since there are only three possible values (clay, grass, hard), duplicating this information has a negligible impact on storage.Furthermore, the surface of a tournament is a priori a static attribute, meaning it does not\nchange over time.This eliminates the risk of inconsistency or complex update operations,\nfurther reinforcing the relevance of using surcharge in this context.", "time.This eliminates the risk of inconsistency or complex update operations, further reinforcing the relevance of using surcharge in this context.Here is Json Schema for the match scores table after denormalization by surcharge:\n{\n\"tourney_year_id\": \"2023-001\",\n\"tourney_slug\": \"us-open\",\n\u201cwinner_name\": \"Novak Djokovic\",\n\"winner_player_id\": \"d124\",\n\"loser_name\": \"Daniil Medvedev\",\n\"loser_player_id\": \"c125\",\n\"score\": \"64, 63, 64\",\n\"surface\": \"clay\" <<---\n...\n}\nWe just added the type of the surface for each match thanks to the tournaments table.", "\"clay\" <<--- ... } We just added the type of the surface for each match thanks to the tournaments table.Now,\nthe query (DA-B) would be the same but without the join.It could have been interesting to use a \u201cMat\u00e9rialisation\u201d approach to optimize the query\n(DA-B): one could have precomputed the winning statistics for each surface for each player\nand stored them in the player overview table.", "could have precomputed the winning statistics for each surface for each player and stored them in the player overview table.However, since these statistics are not static\n(the players continue to play), we believe that this approach is not the most appropriate.2.2: Second denormalization (Fusion):\nNow, let us deep dive into a more complicated scenario, let us consider the query (DA-A),\nwhich includes a join between match stats table and match scores table.", "complicated scenario, let us consider the query (DA-A), which includes a join between match stats table and match scores table.In order to avoid the join, we believe that we should embed the match stats table inside the\nmatch scores table and thus achieve a \u201cFusion\u201d.", "we believe that we should embed the match stats table inside the match scores table and thus achieve a \u201cFusion\u201d.Here are the Json Schema before and after the denormalization:\nJson Schema before the denormalization:\n{\n\"match_scores\": {\n\"match_id\": \"M001\",\n\"tournament_id\": \"T001\",\n\"winner\": \"Novak Djokovic\",\n\"loser\": \"Rafael Nadal\",\n\"score\": \"63, 62\"\n...\n}\n}\n{\n\"match_stats\": {\n\"match_id\": \"M001\",\n\"winner_serve_rating\": 85,\n\"loser_serve_rating\": 78,\n...\n}\n}", "\"Rafael Nadal\", \"score\": \"63, 62\" ... } } { \"match_stats\": { \"match_id\": \"M001\", \"winner_serve_rating\": 85, \"loser_serve_rating\": 78, ... } }Json Schema after the denormalization (Fusion):\n{\n\"match_id\": \"M001\",\n\"tournament\": {\n\"id\": \"T001\",\n\"name\": \"Wimbledon\"\n},\n\"players\": {\n\"winner\": \"Novak Djokovic\",\n\"loser\": \"Rafael Nadal\"\n},\n\"stats\": {\n\"winner_serve_rating\": 85,\n\"loser_serve_rating\": 78,\n.", "\"T001\", \"name\": \"Wimbledon\" }, \"players\": { \"winner\": \"Novak Djokovic\", \"loser\": \"Rafael Nadal\" }, \"stats\": { \"winner_serve_rating\": 85, \"loser_serve_rating\": 78, ...\n}}\nWe could also embed other statistics which are often interesting in order to avoid making a\njoin each time.", "}} We could also embed other statistics which are often interesting in order to avoid making a join each time.Moreover, once a game is played, its statistics do not change; they are static.Thus, the\ndenormalization will not imply synchronisation over time, which is optimal.", "played, its statistics do not change; they are static.Thus, the denormalization will not imply synchronisation over time, which is optimal.About the cardinality, the relationship between match_scores and match_stats is one-to-one\n(1:1), Because of this low-cardinality relationship, embedding is an efficient solution since it\ndoes not lead to excessive data duplication.", "With this denormalization, a join will no longer be necessary in the query (DA-A),\naccelerating the query."]